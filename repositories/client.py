# ============================================================================
# CLIENT REPOSITORY
# ============================================================================
# This file was auto-generated on: 2025-09-24 23:30:59 WAT
# It contains asynchronous functions for managing access to the database
# in a MongoDB database using FastAPI.
#
# DO NOT EDIT THIS FILE MANUALLY - RE-RUN THE GENERATOR INSTEAD. OR IF YOU WANT TO EDIT JUST ADD LEAVE OTHER FUNCTIONS THE WAY YOU MET THEM
# ============================================================================

from pymongo import ReturnDocument
from core.database import db
from fastapi import HTTPException,status
from typing import List,Optional
from schemas.user_schema import UserOut,UserCreate,UserUpdate


async def get_client(filter_dict: dict) -> Optional[UserOut]:
    try:
        # Combine the user-provided filter with the role filter
        role_filter = {"role.name": "client"}
        combined_filter = {**filter_dict, **role_filter}

        result = await db.users.find_one(combined_filter)

        if result is None:
            return None

        return UserOut(**result)

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An error occurred while fetching client: {str(e)}"
        )
        
    
async def get_clients(filter_dict: dict = {},start=0,stop=100) -> List[UserOut]:
    try:
        if filter_dict is None:
            filter_dict = {}

        # Combine the user-provided filter with the role filter
        role_filter = {"role.name": "client"}
        combined_filter = {**filter_dict, **role_filter}

        cursor = (db.users.find(combined_filter)
        .skip(start)
        .limit(stop - start)
        )
        client_list = []

        async for doc in cursor:
            client_list.append(UserOut(**doc))

        return client_list

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An error occurred while fetching clients: {str(e)}"
        )
        
        

async def update_client(filter_dict: dict, client_data: UserUpdate) -> UserOut:
    # Combine the user-provided filter with the role filter
    role_filter = {"role.name": "client"}
    combined_filter = {**filter_dict, **role_filter}

    # Ensure the client's role is not accidentally updated to something else
    update_data = client_data.model_dump(exclude_none=True)
    if 'role' in update_data:
        del update_data['role'] # Prevent accidental role changes

    result = await db.users.find_one_and_update(
        combined_filter,
        {"$set": update_data},
        return_document=ReturnDocument.AFTER
    )
    
    if result is None:
        # Handle case where no document was found/updated
        raise HTTPException(status_code=404, detail="Client not found or not authorized to update.")

    returnable_result = UserOut(**result)
    return returnable_result



async def delete_client(filter_dict: dict):
    # Combine the user-provided filter with the role filter
    role_filter = {"role.name": "client"}
    combined_filter = {**filter_dict, **role_filter}
    
    return await db.users.delete_one(combined_filter)



async def create_client(client_data: UserCreate) -> UserOut:
    client_dict = client_data.model_dump()
    
    # Inject the mandatory role for a new "client" user
    client_dict["role"] = {
        "name": "client",
        "description": "This user creates Job Postings"
    }

    result = await db.users.insert_one(client_dict)
    
    # We find the inserted document by its ID; no need for role filter here
    result = await db.users.find_one(filter={"_id":result.inserted_id})
    returnable_result = UserOut(**result)
    return returnable_result