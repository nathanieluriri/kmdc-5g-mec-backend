# ============================================================================
# AGENT REPOSITORY
# ============================================================================
# This file was auto-generated on: 2025-09-24 23:30:59 WAT
# It contains asynchronous functions for managing access to the database
# in a MongoDB database using FastAPI.
#
# DO NOT EDIT THIS FILE MANUALLY - RE-RUN THE GENERATOR INSTEAD. OR IF YOU WANT TO EDIT JUST ADD LEAVE OTHER FUNCTIONS THE WAY YOU MET THEM
# ============================================================================

from pymongo import ReturnDocument
from core.database import db
from fastapi import HTTPException, status
from typing import List, Optional
from schemas.user_schema import UserOut, UserCreate, UserUpdate


async def get_agent(filter_dict: dict) -> Optional[UserOut]:
    try:
        role_filter = {"role.name": "agent"}
        combined_filter = {**filter_dict, **role_filter}

        result = await db.users.find_one(combined_filter)

        if result is None:
            return None

        return UserOut(**result)

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An error occurred while fetching agent: {str(e)}"
        )


async def get_agents(filter_dict: dict = {}, start=0, stop=100) -> List[UserOut]:
    try:
        if filter_dict is None:
            filter_dict = {}

        role_filter = {"role.name": "agent"}
        combined_filter = {**filter_dict, **role_filter}

        cursor = (
            db.users.find(combined_filter)
            .skip(start)
            .limit(stop - start)
        )
        agent_list = []

        async for doc in cursor:
            agent_list.append(UserOut(**doc))

        return agent_list

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"An error occurred while fetching agents: {str(e)}"
        )


async def update_agent(filter_dict: dict, agent_data: UserUpdate) -> UserOut:
    role_filter = {"role.name": "agent"}
    combined_filter = {**filter_dict, **role_filter}

    update_data = agent_data.model_dump(exclude_none=True)
    if 'role' in update_data:
        del update_data['role']  # Prevent accidental role changes

    result = await db.users.find_one_and_update(
        combined_filter,
        {"$set": update_data},
        return_document=ReturnDocument.AFTER
    )

    if result is None:
        raise HTTPException(status_code=404, detail="Agent not found or not authorized to update.")

    return UserOut(**result)


async def delete_agent(filter_dict: dict):
    role_filter = {"role.name": "agent"}
    combined_filter = {**filter_dict, **role_filter}

    return await db.users.delete_one(combined_filter)


async def create_agent(agent_data: UserCreate) -> UserOut:
    agent_dict = agent_data.model_dump()

    # Inject the mandatory role for a new "agent" user
    agent_dict["role"] = {
        "name": "agent",
        "description": "This user accepts job postings"
    }

    result = await db.users.insert_one(agent_dict)

    result = await db.users.find_one(filter={"_id": result.inserted_id})
    return UserOut(**result)
